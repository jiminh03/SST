# 백엔드 기능 명세

상태: 진행 중
프로젝트: PJT 2 (https://www.notion.so/PJT-2-259cce47468a80ce83f6c643676c850f?pvs=21)

## 아키텍처

### 시스템 아키텍처

```mermaid
graph TD
    subgraph "사용자 환경"
        A["FE<br/> (관리자/보호자 웹)"]
        B["어르신 자택<br/> (IoT 홈 허브 & 로봇)"]
    end

    subgraph "클라우드 인프라"
        C[API Gateway / Nginx]

        D["<b>백엔드 서버 (FastAPI)</b>"]
        E["<b>AI 실행 서버</b>"]
        F["<b>AI 학습 서버</b>"]
        G["<b>관계형 DB (PostgreSQL)</b>"]
        H["<b>시계열 DB (TimescaleDB)</b><br/>센서 로그 데이터"]
        I["<b>오브젝트 스토리지 (S3)</b><br/>AI 모델 가중치 원본"]
        J["<b>[Cache & MQ] Redis</b><br/>- AI 가중치 캐시<br/>- 실시간 이벤트 전달"]
    end

    %% --- Data Flows ---
     A <-- "HTTPS (API, WebSocket, WebRTC Signaling)" --> C
    C --- D
    B -- "Sensor Logs" --> C
    C <-- "WSS: 어르신 안전 확인" --> B
    
    D <-- "DB CRUD" --> G
    D -- "Sensor Log 저장" --> H
    D <-- "DB 캐싱" --> J

    %% AI 실행 서버의 데이터 흐름
    H -- "최신 센서 데이터 조회" --> E
    E -- "위험도 상태 갱신" --> D
    I -- "최신 가중치 로드" --> E
    E -- "개인 가중치 경로 조회" --> D

    %% AI 학습 서버의 데이터 흐름
    I -- "기존 가중치 로드" --> F
    F -- " 가중치 등록 신청<br/>기존 가중치 경로 조회" --> D
    J <-- "가중치 캐싱 및 로드" --> E

    %% 긴급 상황 발생 시 Redis Pub/Sub 흐름
    E -- "MQ: 긴급 상황 발행 <br/>(Publish)" --> J
    J -- "MQ: 메시지 수신 <br/>(Subscribe)" --> D

    %% AI 학습 서버는 동일
    H -- "학습 데이터 제공" --> F
    F -- "학습 후 가중치 저장" --> I

    %% WebRTC Flow는 동일
    B -- "WebRTC(미디어 스트림-P2P)" --> A
```

- 아키텍처 설계 의도
    - 메세지 큐를 통해 AI 추론시 이상치 검출되면 즉시 백엔드에게 빠르게 알림
    - redis를 통해 빠른 가중치 로딩을 구현하여 여러 어르신의 가중치를 하나의 머신에서 동시에 실행시킬 수 있음
    - DB의 CUD는 백엔드만 담당하고 AI서버에서는 R만 할 수 있게하여 데이터를 사용하는 입장에서는 백엔드를 거치지 않고 데이터를 빠르게 접근 가능하고 백엔드는 데이터를 일관적으로 관리할 수 있음
    - WebSocket을 통해 실제 클라이언트의 반응도 서버가 확인하여 응급 알림이 제대로 확인 되었는 지, 안전 로봇이 안전 확인 요청을 잘 받았는 지 확인

### WebRTC 기반 스트리밍 흐름도

```mermaid
sequenceDiagram
    participant Robot as "로봇"
    participant HomeHub as "IoT 홈 허브"
    participant Backend as "백엔드 서버 (시그널링 & 미디어 중계)"
    participant FE as "FE (관리자 웹)"

    Note over Robot, HomeHub: 로봇은 홈 허브로 실시간 영상을 전송 중 (예: RTSP)

    %% 1. FE에서 영상 요청 시작
    FE->>Backend: 1. 특정 로봇 영상 스트림 요청 (API or WebSocket)
    activate Backend

    %% 2. 백엔드와 홈 허브 간의 WebRTC 연결 (Backend가 영상 수신)
    Backend->>HomeHub: 2. WebRTC 연결 요청 (Publish)
    activate HomeHub
    HomeHub->>HomeHub: 3. PeerConnection 생성 & 로봇 영상 트랙 추가
    HomeHub->>Backend: 4. SDP Offer 전송
    deactivate HomeHub
    
    Backend->>Backend: 5. 수신용 PeerConnection에 Offer 설정
    Backend->>HomeHub: 6. SDP Answer 생성 및 회신
    activate HomeHub
    HomeHub->>HomeHub: 7. Answer 설정 및 ICE Candidate 교환
    deactivate HomeHub
    
    Note over HomeHub, Backend: 미디어 스트림 연결 수립 (영상: Hub -> Backend)

    %% 3. 백엔드와 FE 간의 WebRTC 연결 (Backend가 영상 송신)
    Backend->>Backend: 8. 송신용 PeerConnection 생성 & 수신한 영상 트랙 추가
    Backend->>FE: 9. 새로운 SDP Offer 전송 (Subscribe)
    deactivate Backend
    
    activate FE
    FE->>FE: 10. PeerConnection 생성 및 Offer 설정
    FE->>Backend: 11. SDP Answer 생성 및 회신
    activate Backend
    Backend->>Backend: 12. Answer 설정 및 ICE Candidate 교환
    deactivate Backend
    
    Note over Backend, FE: 미디어 스트림 연결 수립 (영상: Backend -> FE)
    deactivate FE

    Note over Robot, FE: 최종 영상 흐름: 로봇 -> 홈 허브 -> 백엔드 -> FE
```

### 가중치 로딩

```mermaid
%%-- 실제 캐싱 정책은 다중 이용자에 대한 패턴 분석 스케줄링 정책에 맞게 구체화할 예정
graph TD
    subgraph "AI 가중치 로딩 흐름"
        A[AI 실행 서버, 특정 어르신 가중치 요청] --> B{Redis 캐시에<br/>가중치 존재?}
        
        B -- "✅ Yes (Hit)" --> C["매우 빠르게<br/>Redis에서 가중치 로드"]
        
        B -- "❌ No (Miss)" --> D["S3에서<br/>원본 가중치 로드<br/>(상대적으로 느림)"]
        D --> E["Redis에 가중치 저장<br/>(다음 요청을 위해 캐싱)"]
        
        C --> F["가중치를 사용하여<br/>이상치 탐지 수행"]
        E --> F
    end
```

## ERD

```mermaid
erDiagram
    %% --- Entities Definition ---

    STAFFS {
        int staff_id PK "직원 고유 ID"
        string email UK "email"
        string password_hash "비밀번호 해시"
        string full_name "이름"
        datetime created_at "생성일"
    }

    SENIORS {
        int senior_id PK "어르신 고유 ID"
        string full_name "이름"
        string address "주소"
        json health_info "건강 정보 (지병, 복용약 등)"
        datetime created_at "등록일"
    }

    STAFF_SENIOR_MAP {
        int staff_id PK, FK "직원 ID"
        int senior_id PK, FK "어르신 ID"
    }

    IOT_HUBS {
        int hub_id PK "홈 허브 고유 ID"
        int senior_id FK "연결된 어르신 ID"
        string device_id UK "기기 고유 번호 (e.g., MAC 주소)"
        string api_key_hash "발급된 API 키 해시"
        string status "상태 (e.g., online, offline)"
        datetime last_seen_at "마지막 접속 시간"
        datetime registered_at "등록일"
    }

    AI_WEIGHTS {
        int weight_id PK "가중치 고유 ID"
        int senior_id FK "대상 어르신 ID"
        int version "버전"
        string storage_path "가중치 파일 경로 (Object Storage)"
        boolean is_active "현재 사용 여부"
        datetime created_at "생성일"
    }

    EMERGENCY_LOGS {
        int log_id PK "로그 고유 ID"
        int senior_id FK "대상 어르신 ID"
        string event_type "이벤트 종류 (e.g., fall_detection)"
        string description "상세 내용"
        datetime occurred_at "발생 시각"
        datetime resolved_at "조치 완료 시각"
    }

    %% --- Time-Series Data (Logical Representation) ---
    %% 시계열 데이터(센서 로그)는 별도의 Time-Series DB(e.g., TimescaleDB)에 저장됩니다.
    %% 아래는 개념적 표현이며, 실제 테이블은 관계형 DB에 존재하지 않습니다.
    SENSOR_LOGS {
        datetime timestamp "타임스탬프"
        string sensor_id "센서 위치/ID"
        string event_content "이벤트 내용"
        boolean sensor_value "센서 값 (True/False)"
        int hub_id "로그를 전송한 홈 허브 ID"
    }

    %% --- Relationships Definition ---

    STAFFS ||--|{ STAFF_SENIOR_MAP : "manages"
    SENIORS ||--|{ STAFF_SENIOR_MAP : "is managed by"

    SENIORS ||--|| IOT_HUBS : "has one"
    SENIORS ||--|{ AI_WEIGHTS : "has personal"
    SENIORS ||--|{ EMERGENCY_LOGS : "has"
```

## api 명세 기획

### 인증

1. 직원 로그인 기능
2. 노인 및 기기 등록
3. api 키 발급
4. 기기 등록 해지

### 사용자 관리 및 모니터링

1. 사용자 리스트 조회
2. 사용자 세부 정보 조회
3. 사용자 응급 상황 로그 조회

### IoT

1. 센서 이벤트 로그 전송
2. 어르신 안전 확인

### AI

1. 가중치 경로 조회
2. 가중치 등록 신청